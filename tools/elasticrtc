#!/usr/bin/env python
##### IMPORTS #####
import os
import sys
if sys.version_info[0] > 2:
    print (  "\n====================================\n"
            +"\n   Python version not supported : " + str(sys.version_info[0]) + "." + str(sys.version_info[1]) + "\n"
            +"\n====================================\n")
    sys.exit(1)
def require (module, description):
    print ( "\n====================================\n"
            "\n   "+ description +" not installed. Execute as administrator:"
            "\n      pip install " + module +
            "\n"
            "\n   In order to install pip download from https://bootstrap.pypa.io/get-pip.py"
            "\n   and execute as adminstrator:"
            "\n"
            "\n      python get-pip.py"
            "\n====================================\n")
    sys.exit (1)

import subprocess
import getopt
import re
import datetime
import time
import json
import pprint
import ConfigParser
ConfigParser.DEFAULTSECT='default'
import hashlib
import collections
try:
    import OpenSSL.crypto as crypto
except Exception as e:
    require ('pyOpenSSL', 'Open SSL')
import ssl
import re
import operator
try:
    import boto3
except Exception as e:
    require ('boto3', 'AWS SDK')
try:
    import dns.resolver
except Exception as e:
    require ('dnspython', 'DNS module')

##### CONSTANTS #####
#KMS_AMI_NAME = 'KMS-CLUSTER-6.1.1.trusty-0.0.1-SNAPSHOT-20151115110730'
KMS_AMI_DESCRIPTION = 'kmscluster-controller'
ROOM_AMI_DESCRIPTION = 'kurento-room-sfu-demo'
TEMPLATE_FILE = "aws" + os.sep + "elasticrtc-template.json"
AWS_CONFIG_DIR = os.path.expanduser('~') + os.sep + '.aws'
AWS_CREDENTIALS_FILE = AWS_CONFIG_DIR + os.sep + 'credentials'
AWS_CONFIG_FILE = AWS_CONFIG_DIR + os.sep + 'config'
AWS_PROFILE = 'profile'
AWS_ACCESS_KEY_ID = 'aws_access_key_id'
AWS_SECRET_ACCESS_KEY = 'aws_secret_access_key'

# Error messages
LINE = "\n====================================\n"
CR = "\n"
I = "     "
I2 = I+I
I3 = I2+ "          "
CMD = "usage: " + os.path.basename(__file__) + " - "
CMD_CREATE = "create"
CMD_DELETE = "delete"
CMD_LIST = "list"
CMD_SHOW = "show"
CMD_UPDATE = "update"
CMD_VERSION = "version"
CMDS = [ CMD_CREATE, CMD_DELETE, CMD_UPDATE, CMD_LIST, CMD_SHOW, CMD_VERSION]

PARAM_APP_URL = "app-url"
PARAM_AWS_ACCESS_KEY_ID = "aws-access-key-id"
PARAM_AUTOSCALING_HEARTBEAT_TIMEOUT="autoscaling-heartbeat-timeout"
PARAM_AWS_INSTANCE_TENANCY = "aws-instance-tenancy"
PARAM_AWS_INSTANCE_TYPE = "aws-instance-type"
PARAM_AWS_APP_INSTANCE_TYPE = "aws-app-instance-type"
PARAM_AWS_KEY_NAME = "aws-key-name"
PARAM_AWS_S3_BUCKET_NAME = "aws-s3-bucket-name"
PARAM_AWS_SECRET_ACCESS_KEY = "aws-secret-access-key"
PARAM_CONTROL_ORIGIN = "control-origin"
PARAM_COST_MAP = "cost-map"
PARAM_DESIRED_CAPACITY = "desired-capacity"
PARAM_ELASTICSEARCH_TRANSPORT = "elasticsearch-transport"
PARAM_ELASTICSEARCH_USER = "elasticsearch-user"
PARAM_ELASTICSEARCH_PASS = "elasticsearch-password"
PARAM_ELASTICSEARCH_SSL = "elasticsearch-ssl"
PARAM_ENABLE_APP = "enable-app"
PARAM_ENABLE_TURN = "enable-turn"
PARAM_HEALTH_CHECK_GRACE_PERIOD = "health-check-grace-period"
PARAM_HOSTED_ZONE_ID = "hosted-zone-id"
PARAM_INSPECTOR_USER = "inspector-user"
PARAM_INSPECTOR_PASS = "inspector-pass"
PARAM_J = "j"
PARAM_KMSCLUSTER_CONTROLLER_URL="kmscluster-controller-url"
PARAM_KURENTO_API_KEY = "api-key"
PARAM_KURENTO_API_ORIGIN = "api-origin"
PARAM_LOG_STORAGE = "log-storage"
PARAM_MIN_CAPACITY = "min-capacity"
PARAM_MAX_CAPACITY = "max-capacity"
PARAM_REGION = "region"
PARAM_SESSION_RECONNECTION_TIME ="session-reconnection-time"
PARAM_SCALE_IN_POLICY = "scale-in-policy"
PARAM_SCALE_OUT_POLICY = "scale-out-policy"
PARAM_SSL_CERT = "ssl-cert"
PARAM_SSL_KEY = "ssl-key"
PARAM_STACK_NAME = "stack-name"
PARAM_TEST_MODE = "test-mode"
PARAM_USE_PROXY = "use-proxy"
PARAM_VERSION = "version"

# Usage Messages
USAGE_CLI = CMD + CR
USAGE_CLI_CREATE = CMD + CMD_CREATE + CR
USAGE_CLI_DELETE = CMD + CMD_DELETE + CR
USAGE_CLI_LIST = CMD + CMD_LIST + CR
USAGE_CLI_SHOW = CMD + CMD_SHOW + CR
USAGE_CLI_UPDATE = CMD + CMD_UPDATE + CR
USAGE_CLI_VERSION = CMD + CMD_VERSION + CR
USAGE_COMMAND_LIST = CR + I + "Commands:" + CR
USAGE_PARAM_LIST = CR + I + "Options:" + CR
USAGE_CREATE_CMD = I2 + CMD_CREATE + "  Create elasticRTC Cluster." + CR
USAGE_DELETE_CMD = I2 + CMD_DELETE + "  Delete elasticRTC Cluster." + CR
USAGE_LIST_CMD =   I2 + CMD_LIST + "    List elasticRTC Clusters." + CR
USAGE_SHOW_CMD =   I2 + CMD_SHOW + "    Show elasticRTC Cluster details." + CR
USAGE_SHOW_CMD =   I2 + CMD_UPDATE + "    Updates an already existing elasticRTC Cluster." + CR
USAGE_VERSION_CMD = I2 + CMD_VERSION + " List available version in region." + CR
USAGE_HELP_CMD = CR+I2 + "See '" + os.path.basename(__file__) + " help COMMAND' for help on a specific command." + CR

USAGE_AWS_ACCESS_KEY_ID = (CR+I2+ "--" + PARAM_AWS_ACCESS_KEY_ID + " value"
    +CR+I3+ "[Optional] Access Key Id required to connect AWS APIs. If not provided"
    +CR+I3+ "it will be used default configurations in file ~/.aws/credentials."
    +CR+I3+ "Go to following link for more info:"
    +CR+I3+ "  http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html"
    +CR)

USAGE_AWS_INSTANCE_TENANCY = (CR+I2+ "--" + PARAM_AWS_INSTANCE_TENANCY + " [default|dedicated|host]"
    +CR+I3+ "[Optional] EC2 tenancy of cluster nodes. Default value is default. For"
    +CR+I3+ "more information on EC2 dedicated instaces visit:"
    +CR+I3+ "http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/dedicated-instance.html"
    +CR)

USAGE_AWS_INSTANCE_TYPE = (CR+I2+ "--" + PARAM_AWS_INSTANCE_TYPE + " value"
    +CR+I3+ "[Optional] EC2 instance type used by cluster nodes. Default"
    +CR+I3+ "instance type is m3.medium"
    +CR
    +CR+I2+ "--" + PARAM_AWS_APP_INSTANCE_TYPE + " value"
    +CR+I3+ "[Optional] EC2 instance type used by app node when an APP is"
    +CR+I3+ "enabled. Same instance type of cluster nodes will be used if not"
    +CR+I3+ "specified"
    +CR)

USAGE_AWS_KEY_NAME = (CR+I2+ "--" + PARAM_AWS_KEY_NAME + " value"
    +CR+I3+ "[Optional] Name of Amazon EC2 key pair to be configured in nodes."
    +CR+I3+ "More information available in:"
    +CR+I3+ "http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html"
    +CR)

USAGE_AWS_S3_BUCKET_NAME = (CR+I2+ "--" + PARAM_AWS_S3_BUCKET_NAME + " value"
    +CR+I3+ "[Optional] Name of Amazon S3 bucket used for permanent storage."
    +CR+I3+ "A new bucket named: <region>-<stack-name> will be created if this"
    +CR+I3+ "parameter is not provided. Notice buckets are never deleted on"
    +CR+I3+ "termination, even if they have been created by cluster tools."
    +CR)

USAGE_AWS_SECRET_ACCESS_KEY = (CR+I2+ "--" + PARAM_AWS_SECRET_ACCESS_KEY + " value"
    +CR+I3+ "[Optional] Secret Access Key required to connect AWS APIs. If not"
    +CR+I3+ "provided it will be used default configurations in file"
    +CR+I3+ "~/.aws/credentials. Go to following link for more info:"
    +CR+I3+ "  http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html"
    +CR)

USAGE_CONTROL_ORIGIN = (CR+I2 + "--" + PARAM_CONTROL_ORIGIN + " cidr"
    +CR+I3+ "[Optional] CIDR from where SSH connections will be allowed. Default"
    +CR+I3+ "value is 0.0.0.0/0, allowing connections from anywhere."
    +CR)

USAGE_COST_MAP = (CR+I2 + "--" + PARAM_COST_MAP + " key=value[,key=value ...]"
    +CR+I3+ "[Optional] Map of MediaElement costs for Load calculation. This flag"
    +CR+I3+ "accepts a comma separated list of key-value pairs with the cost description"
    +CR+I3+ "of each MediaElement."
    +CR)


USAGE_DESIRED_CAPACITY = (CR+I2 + "--" + PARAM_DESIRED_CAPACITY + " num"
    +CR+I3+ "[Optional] Number of KMS instances to be deployed by Kurento"
    +CR+I3+ "Cluster. AWS will take care to terminate failed instances in order"
    +CR+I3+ "to maintain desired cluster capacity. Desired capacity will default"
    +CR+I3+ "to minimun cluster capacity and then to 1 if no capacity configuration"
    +CR+I3+ "is provided. Visit http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-manual-scaling.html"
    +CR+I3+ "for more information on autoscaling."
    +CR)


USAGE_ENABLE_APP = (CR+I2+ "--" + PARAM_ENABLE_APP + " room"
    +CR+I3+ "[Optional] It deploys cluster with an embedded application. Currently"
    +CR+I3+ "only application ROOM is supported. Application will be accessible in"
    +CR+I3+ "URL: http[s]://cluster-url/app. HTTP or HTTPS will be used depending"
    +CR+I3+ "on SSL being enabled or not."
    +CR)

USAGE_ENABLE_TURN = (CR+I2+ "--" + PARAM_ENABLE_TURN + " (true|false)"
    +CR+I3+ "[Optional] Whether to enable or disable internal STUN/TURN server."
    +CR+I3+ "When enabled, each cluster node will run a TURN server protected"
    +CR+I3+ "by a random user and passwords. An IceServers object with all TURN"
    +CR+I3+ "URLs in cluster is provided in the Metadata object, that can be"
    +CR+I3+ "retrieved using Kurento client"
    +CR)

USAGE_INSPECTOR = (CR+I2 + "--" + PARAM_INSPECTOR_USER + " value"
    +CR+I3+ "[Optional] This username will be configured in the Inspector"
    +CR+I3+ "monitor application in order to control access to its web console."
    +CR+I3+ "Default value is admin."
    +CR
    +CR+I2+ "--" + PARAM_INSPECTOR_PASS + " num"
    +CR+I3+ "[Optional] This string will be configured as password for the"
    +CR+I3+ "Inspector application. Default value is admin."
    +CR)

USAGE_KURENTO_API_KEY = (CR+I2+ "--" + PARAM_KURENTO_API_KEY + " value"
    +CR+I3+ "[Optional] A secret string intended to control access to cluster"
    +CR+I3+ "API. Cluster will accept requests from any client presenting"
    +CR+I3+ "this key. This key is an alphanumeric non empty string of"
    +CR+I3+ "any length that is concatenated to the cluster URL:"
    +CR
    +CR+I3+ "       ws[s]://host/<"+ PARAM_KURENTO_API_KEY +">"
    +CR
    +CR+I3+ "Default value is kurento."
    +CR)

USAGE_KURENTO_API_ORIGIN = (CR+I2+ "--" + PARAM_KURENTO_API_ORIGIN + " cidr"
    +CR+I3+ "[Optional] CIDR from where KMS API request will be allowed. Default"
    +CR+I3+ "value is 0.0.0.0/0, allowing connections from anywhere."
    +CR)

USAGE_ENABLE_APP = (CR+I2+ "--" + PARAM_ENABLE_APP + " room"
    +CR+I3+ "[Optional] It deploys cluster with an embedded application. Currently"
    +CR+I3+ "only application ROOM is supported. Application will be accessible in"
    +CR+I3+ "URL: http[s]://cluster-url/app. HTTP or HTTPS will be used depending"
    +CR+I3+ "on SSL being enabled or not."
    +CR)

USAGE_LOG_STORAGE = (CR+I2+ "--" + PARAM_LOG_STORAGE + " [cloudwatch|s3|elasticsearch|none]"
    +CR+I3+ "[Optional] Storage location of logs. It can be any of AWS"
    +CR+I3+ "Cloudwatch Logs , AWS S3 services, an external Elasticsearch service"
    +CR+I3+ "or no cloud storage. If Elasticsearch is selected but no transport"
    +CR+I3+ "is provided, the system goes to default value: none"
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_TRANSPORT + " address[:port]"
    +CR+I3+ "[Optional] This flag must be provided when log storage is set to"
    +CR+I3+ "elasticsearch. It defines the transport address and port where the"
    +CR+I3+ "Elasticsearch service listens for requests. If no port is provided,"
    +CR+I3+ "default value, 9200, is used. If this flag is not provided when log"
    +CR+I3+ "storage is set to elasticsearch, then log storage defaults to cloudwatch"
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_USER + " value"
    +CR+I3+ "[Optional] Elasticsearch username. Anonymous access will be configured if"
    +CR+I3+ "not provided."
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_PASS + " value"
    +CR+I3+ "[Optional] Elasticsearch password. Anonymous access will be configured if"
    +CR+I3+ "not provided."
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_SSL + " boolean"
    +CR+I3+ "[Optional] Wheter to use SSL or not when connecting to Elasticsearch. Default"
    +CR+I3+ "value is false."
    +CR )

USAGE_MAX_CAPACITY = (CR+I2 + "--" + PARAM_MAX_CAPACITY + "num"
    +CR+I3+ "[Optional] Maximum number of nodes allowed in the cluster. Autoscaling"
    +CR+I3+ "is disabled if this configuration is not provided, even if a scale out"
    +CR+I3+ "policy is defined."
    +CR)

USAGE_MIN_CAPACITY = (CR+I2+ "--" + PARAM_MIN_CAPACITY + "num"
    +CR+I3+ "[Optional] Minimum number of nodes allowed in the cluster. Autoscaling"
    +CR+I3+ "is disabled if this configuration is not provided, even if a scale in"
    +CR+I3+ "policy is defined."
    +CR)

USAGE_REGION = (CR+I2+ "--"  + PARAM_REGION + " value"
    +CR+I3+ "[Mandatory] AWS region where cluster is deployed. Can be any of:"
    +CR+I3+ "  ap-northeast-1   Asia Pacific (Tokyo)"
    +CR+I3+ "  ap-southeast-1   Asia Pacific (Singapore)"
    +CR+I3+ "  ap-southeast-2   Asia Pacific (Sydney)"
    +CR+I3+ "  eu-central-1     EU (Frankfurt)"
    +CR+I3+ "  eu-west-1        EU (Ireland)"
    +CR+I3+ "  sa-east-1        South America (Sao Paulo)"
    +CR+I3+ "  us-east-1        US East (N. Virginia)"
    +CR+I3+ "  us-west-1        US West (N. California)"
    +CR+I3+ "  us-west-2        US West (Oregon)"
    +CR+I3+ "Visit http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html"
    +CR+I3+ "for more information."
    +CR)

USAGE_ROUTE53 =(CR+I2+ "--" + PARAM_HOSTED_ZONE_ID + " value"
    +CR+I3+ "[Optional] Route 53 hosted zone ID used by cluster to automatically"
    +CR+I3+ "register a CNAME record with the name of the stack. If a SSL"
    +CR+I3+ "certificate is provided its common name (CN) must match the hosted"
    +CR+I3+ "zone domain."
    +CR)

USAGE_SCALE_POLICY = (CR+I2 + "--" + PARAM_SCALE_IN_POLICY + "key=val[,key=val ...]"
    +CR+I3+ "[Optional] Set of key-value pairs with the definition of Load"
    +CR+I3+ "thresholds and their associated capacity reduction. A pair of"
    +CR+I3+ "the form 25=10 configures a reduction of 10% in capacity when"
    +CR+I3+ "load becomes 25 units lower than 50%. Default scale in policy"
    +CR+I3+ "is 25=10. "
    +CR
    +CR+I2 + "--" + PARAM_SCALE_OUT_POLICY + "key=val[,key=val ...]"
    +CR+I3+ "[Optional] Set of key-value pairs with the definition of Load"
    +CR+I3+ "thresholds and their associated capacity increase. A pair of"
    +CR+I3+ "the form 25=10 configures an increase of 10% in capacity when"
    +CR+I3+ "load becomes 25 units above 50%. Default scale out policy is"
    +CR+I3+ "25=10."
    +CR)

USAGE_STACK_NAME = (CR+I2+ "--" + PARAM_STACK_NAME + " value"
    +CR+I3+ "[Mandatory] A stack name can contain only alphanumeric characters (case-sensitive) and hyphens. "
    +CR+I3+ "A stack name can contain only alphanumeric characters (case-sensitive) and hyphens."
    +CR)

USAGE_SSL = (CR+I2+ "--" + PARAM_SSL_CERT + " path"
    +CR+I3+ "[Optional] Path to the certificate file used for SSL connections."
    +CR+I3+ "Secure port will be blocked and wss protocol disabled if not provided."
    +CR+I3+ "Due to WebSocket limitation, autosigned certificates are not"
    +CR+I3+ "supported by cluster."
    +CR
    +CR+I2+ "--" + PARAM_SSL_KEY + " path"
    +CR+I3+ "[Optional] Path to the private key associated with SSL certificate. This"
    +CR+I3+ "parameter is mandatory if SSL certificate is provided."
    +CR)

USAGE_J = (CR+I2+ "-" + PARAM_J
    +CR+I3+ "[Optional] Intended for machine to machine interactions. Do not"
    +CR+I3+ "display debug messages and output is provided in JSON format suitable"
    +CR+I3+ "for parsing"
    +CR)

USAGE_VERSION = (CR+I2+ "--" + PARAM_VERSION + " version"
    +CR+I3+ "[Optional] Deploy cluster using this version. An error message is"
    +CR+I3+ "generated is requested version is not found in region. If no version"
    +CR+I3+ "is specified latest one is used."
    +CR)

USAGE_ALL = ( USAGE_CLI
            + USAGE_COMMAND_LIST
            + USAGE_CREATE_CMD
            + USAGE_DELETE_CMD
            + USAGE_LIST_CMD
            + USAGE_SHOW_CMD
            + USAGE_VERSION_CMD
            + USAGE_HELP_CMD
            + USAGE_PARAM_LIST
            + USAGE_J
            + USAGE_KURENTO_API_KEY
            + USAGE_KURENTO_API_ORIGIN
            + USAGE_AWS_ACCESS_KEY_ID
            + USAGE_AWS_SECRET_ACCESS_KEY
            + USAGE_AWS_KEY_NAME
            + USAGE_AWS_S3_BUCKET_NAME
            + USAGE_AWS_INSTANCE_TYPE
            + USAGE_AWS_INSTANCE_TENANCY
            + USAGE_CONTROL_ORIGIN
            + USAGE_COST_MAP
            + USAGE_DESIRED_CAPACITY
            + USAGE_ENABLE_APP
            + USAGE_ENABLE_TURN
            + USAGE_INSPECTOR
            + USAGE_LOG_STORAGE
            + USAGE_MAX_CAPACITY
            + USAGE_MIN_CAPACITY
            + USAGE_REGION
            + USAGE_ROUTE53
            + USAGE_SCALE_POLICY
            + USAGE_SSL
            + USAGE_STACK_NAME
            + USAGE_VERSION
            )

USAGE_CREATE = ( USAGE_CLI_CREATE
               + USAGE_J
               + USAGE_AWS_ACCESS_KEY_ID
               + USAGE_AWS_SECRET_ACCESS_KEY
               + USAGE_AWS_KEY_NAME
               + USAGE_AWS_S3_BUCKET_NAME
               + USAGE_AWS_INSTANCE_TYPE
               + USAGE_AWS_INSTANCE_TENANCY
               + USAGE_CONTROL_ORIGIN
               + USAGE_COST_MAP
               + USAGE_DESIRED_CAPACITY
               + USAGE_INSPECTOR
               + USAGE_KURENTO_API_KEY
               + USAGE_KURENTO_API_ORIGIN
               + USAGE_ENABLE_APP
               + USAGE_ENABLE_TURN
               + USAGE_LOG_STORAGE
               + USAGE_MAX_CAPACITY
               + USAGE_MIN_CAPACITY
               + USAGE_REGION
               + USAGE_ROUTE53
               + USAGE_SCALE_POLICY
               + USAGE_SSL
               + USAGE_STACK_NAME
               + USAGE_VERSION
               )

USAGE_DELETE = ( USAGE_CLI_DELETE
               + USAGE_REGION
               + USAGE_STACK_NAME)

USAGE_UPDATE = ( USAGE_CLI_UPDATE
               + USAGE_REGION
               + USAGE_STACK_NAME)

USAGE_LIST = ( USAGE_CLI_LIST
             + USAGE_J
             + USAGE_REGION
             )

USAGE_SHOW = ( USAGE_CLI_SHOW
             + USAGE_J
             + USAGE_REGION
             + USAGE_STACK_NAME
             )

USAGE_VERSION=(USAGE_CLI_VERSION
             + USAGE_J
             + USAGE_REGION
             )

ALPHANUMERIC_KURENTO_API_KEY = PARAM_KURENTO_API_KEY + " name must be an alphanumeric string"
INVALID_ALPHANUMERIC_STACK_NAME = "Stack name can contain only alphanumeric characters (case-sensitive) and hyphens."
INVALID_ENDWITH_HYPEN_STACK_NAME = "Stack name cannot end with hypen"
INVALID_LENGTH_STACK_NAME = "Stack name cannot be longer than 128 characters."
MISSING_REGION = "Missing mandatory parameter --" + PARAM_REGION
MISSING_STACK_NAME = "Missing mandatory parameter --" + PARAM_STACK_NAME
MISSING_AWS_KEY_NAME = "Missing mandatory parameter --" + PARAM_AWS_KEY_NAME
MISSING_TEMPLATE = "CloudFormation template file not found: " + TEMPLATE_FILE
OPEN_TEMPLATE = "Unable to open CloudFormation template file: " + TEMPLATE_FILE
MIN_LARGER_MAX = "Minimun capacity is larger than maximum capacity"
SCALE_POLICY_BAD_FORMAT = "Wrong format for scale policy: num=num(,num=num)*"

##### LIBRARY ######
out_json = False
def usage (message, info):
    print (LINE)
    if not message is "":
        print (message) + CR
    print (info)
    print (LINE)
    sys.exit(1)

def log (message):
    if not out_json:
        print ("elasticRTC: " + message)

def log_warn (message):
    if not out_json:
        print ("WARN: " + message)

def log_error (message):
    print (LINE)
    print ("ERROR: " + message)
    print (LINE)
    sys.exit(1)

class KurentoClusterConfig:
    "Kurento Cluster Configuration"

    kurento_tools_home = os.path.dirname(__file__) + os.sep + ".."

    command = None

    aws_access_key_id = None
    aws_secret_access_key = None
    aws_key_name = None
    aws_s3_bucket_name = None
    aws_instance_type = None
    aws_app_instance_type = None
    aws_instance_tenancy = None
    cluster_fqdn = None
    control_origin = None
    cost_map = None
    desired_capacity = None
    elasticsearch_transport = None
    elasticsearch_user = None
    elasticsearch_pass = None
    elasticsearch_ssl = None
    enable_app = None
    enable_turn = None
    hosted_zone_fqdn = None
    hosted_zone_id = None
    inspector_user = None
    inspector_pass = None
    kurento_api_key = None
    kurento_api_origin = None
    log_storage = None
    max_capacity = None
    min_capacity = None
    region = None
    scale_in_policy = "25=10"
    scale_out_policy = "75=10"
    ssl_cert = None
    ssl_cert_chunks = []
    ssl_key= None
    ssl_common_name = None
    ssl_fqdn = None
    ssl_wildcard = None
    stack_name  = None
    template_file = kurento_tools_home + os.sep + TEMPLATE_FILE
    template_body = None
    turn_username = None
    turn_password = None
    version = None

    aws_param_mappings = {
        'CostMap' : PARAM_COST_MAP,
        'ControlOrigin' : PARAM_CONTROL_ORIGIN,
        'KeyName' : PARAM_AWS_KEY_NAME,
        'DesiredCapacity' : PARAM_DESIRED_CAPACITY,
        'MaxCapacity' : PARAM_MAX_CAPACITY,
        'MinCapacity' : PARAM_MIN_CAPACITY,
        'InspectorUser' : PARAM_INSPECTOR_USER,
        'InspectorPass' : PARAM_INSPECTOR_PASS,
        'InstanceTenancy' : PARAM_AWS_INSTANCE_TENANCY,
        'InstanceType' : PARAM_AWS_INSTANCE_TYPE,
        'AppInstanceType' : PARAM_AWS_APP_INSTANCE_TYPE,
        'ApiKey' : PARAM_KURENTO_API_KEY,
        'ApiOrigin' : PARAM_KURENTO_API_ORIGIN,
        'HostedZoneId' : PARAM_HOSTED_ZONE_ID,
        'UserS3Bucket' : PARAM_AWS_S3_BUCKET_NAME,
        'LogStorage' : PARAM_LOG_STORAGE,
        'ElasticSearchTransport' : PARAM_ELASTICSEARCH_TRANSPORT,
        'ElasticSearchUser' : PARAM_ELASTICSEARCH_USER,
        'ElasticSearchPass' : PARAM_ELASTICSEARCH_PASS,
        'ElasticSearchSsl' : PARAM_ELASTICSEARCH_SSL,
        'SslCertificate1' : PARAM_SSL_CERT,
        'SslKey' : PARAM_SSL_KEY,
        'Version' : PARAM_VERSION
    }

    # Internal parameter
    app_url = None
    autoscaling_heartbeat_timeout = None
    health_check_grace_period = None
    kms_controller_url = None
    session_reconnection_time = None
    test_mode = "false"
    use_proxy = "true"

    def __init__ (self, argv):
        if len(argv) == 0:
            usage ("", USAGE_ALL)
        elif argv[0] == 'help':
            if len(argv) > 1:
                usage ("", self._get_usage(argv[1]))
            usage ("", USAGE_ALL)
        self._read_command(argv[0])
        try:
            opts, args = getopt.getopt(argv[1:],"h" + PARAM_J ,[
                PARAM_AWS_ACCESS_KEY_ID + "=",
                PARAM_AUTOSCALING_HEARTBEAT_TIMEOUT + "=",
                PARAM_AWS_KEY_NAME + "=",
                PARAM_AWS_SECRET_ACCESS_KEY + "=",
                PARAM_AWS_S3_BUCKET_NAME + "=",
                PARAM_AWS_INSTANCE_TENANCY + "=",
                PARAM_AWS_INSTANCE_TYPE + "=",
                PARAM_AWS_APP_INSTANCE_TYPE + "=",
                PARAM_CONTROL_ORIGIN + "=",
                PARAM_COST_MAP + "=",
                PARAM_DESIRED_CAPACITY + "=",
                PARAM_ELASTICSEARCH_TRANSPORT + "=",
                PARAM_ELASTICSEARCH_USER + "=",
                PARAM_ELASTICSEARCH_PASS + "=",
                PARAM_ELASTICSEARCH_SSL + "=",
                PARAM_ENABLE_APP + "=",
                PARAM_ENABLE_TURN + "=",
                PARAM_INSPECTOR_USER + "=",
                PARAM_INSPECTOR_PASS + "=",
                PARAM_KURENTO_API_KEY + "=",
                PARAM_KURENTO_API_ORIGIN + "=",
                PARAM_HOSTED_ZONE_ID + "=",
                PARAM_LOG_STORAGE + "=",
                PARAM_MAX_CAPACITY + "=",
                PARAM_MIN_CAPACITY + "=",
                PARAM_REGION + "=",
                PARAM_SCALE_IN_POLICY + "=",
                PARAM_SCALE_OUT_POLICY + "=",
                PARAM_SSL_CERT + "=",
                PARAM_SSL_KEY + "=",
                PARAM_STACK_NAME + "=",
                "turn-username=",
                "turn-password=",
                PARAM_VERSION +"=",
                # Test parameters. Do not use in production
                PARAM_APP_URL + "=",
                PARAM_HEALTH_CHECK_GRACE_PERIOD + "=",
                PARAM_KMSCLUSTER_CONTROLLER_URL + "=",
                PARAM_SESSION_RECONNECTION_TIME + "=",
                PARAM_TEST_MODE + "=",
                PARAM_USE_PROXY + "="
            ])
            for opt, arg in opts:
                if opt == "-h":
                    usage ("", USAGE_ALL)
                elif opt == "-" + PARAM_J:
                    global out_json
                    out_json=True
                elif opt == "--" + PARAM_AWS_ACCESS_KEY_ID:
                    self.aws_access_key_id = arg
                elif opt == "--" + PARAM_AUTOSCALING_HEARTBEAT_TIMEOUT:
                    self.autoscaling_heartbeat_timeout = arg
                elif opt == "--" + PARAM_AWS_SECRET_ACCESS_KEY:
                    self.aws_secret_access_key = arg
                elif opt == "--" + PARAM_AWS_INSTANCE_TENANCY:
                    self.aws_instance_tenancy = arg
                elif opt == "--" + PARAM_AWS_INSTANCE_TYPE:
                    self.aws_instance_type = arg
                elif opt == "--" + PARAM_AWS_APP_INSTANCE_TYPE:
                    self.aws_app_instance_type = arg
                elif opt == "--" + PARAM_AWS_KEY_NAME:
                    self.aws_key_name = arg
                elif opt == "--" + PARAM_AWS_S3_BUCKET_NAME:
                    self.aws_s3_bucket_name = arg.lower()
                elif opt == "--" + PARAM_DESIRED_CAPACITY:
                    self.desired_capacity = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_TRANSPORT:
                    self.elasticsearch_transport = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_USER:
                    self.elasticsearch_user = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_PASS:
                    self.elasticsearch_pass = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_SSL:
                    self.elasticsearch_ssl = arg
                elif opt == "--" + PARAM_ENABLE_APP:
                    self.enable_app = arg
                elif opt == "--" + PARAM_ENABLE_TURN:
                    self.enable_turn = arg
                elif opt == "--" + PARAM_CONTROL_ORIGIN:
                    self.control_origin = arg
                elif opt == "--" + PARAM_COST_MAP:
                    self.cost_map = arg
                elif opt == "--" + PARAM_KURENTO_API_KEY:
                    self.kurento_api_key = arg
                elif opt == "--" + PARAM_KURENTO_API_ORIGIN:
                    self.kurento_api_origin = arg
                elif opt == "--" + PARAM_HOSTED_ZONE_ID:
                    self.hosted_zone_id = arg
                elif opt == "--" + PARAM_INSPECTOR_USER:
                    self.inspector_user = arg
                elif opt == "--" + PARAM_INSPECTOR_PASS:
                    #m = hashlib.md5()
                    #m.update(arg)
                    #self.inspector_pass = m.hexdigest()
                    self.inspector_pass = arg
                elif opt == "--" + PARAM_LOG_STORAGE:
                    self.log_storage = arg
                elif opt == "--" + PARAM_MAX_CAPACITY:
                    self.max_capacity = arg
                elif opt == "--" + PARAM_MIN_CAPACITY:
                    self.min_capacity = arg
                elif opt == "--" + PARAM_REGION:
                    self.region = arg
                elif opt == "--" + PARAM_SCALE_IN_POLICY:
                    self.scale_in_policy = arg
                elif opt == "--" + PARAM_SCALE_OUT_POLICY:
                    self.scale_out_policy = arg
                elif opt == "--" + PARAM_SSL_CERT:
                    self.ssl_cert = arg
                elif opt == "--" + PARAM_SSL_KEY:
                    self.ssl_key = arg
                elif opt == "--" + PARAM_STACK_NAME:
                    self.stack_name = arg
                elif opt == "--turn-username":
                    self.turn_username = arg
                elif opt == "--turn-password":
                    self.turn_password = arg
                elif opt == "--" + PARAM_VERSION:
                    self.version = arg
                # INTERNAL PARAMETERS
                elif opt == "--" + PARAM_APP_URL:
                    self.app_url = arg
                elif opt == "--" + PARAM_HEALTH_CHECK_GRACE_PERIOD:
                    self.health_check_grace_period = arg
                elif opt == "--" + PARAM_KMSCLUSTER_CONTROLLER_URL:
                    self.kms_controller_url = arg
                elif opt == "--" + PARAM_SESSION_RECONNECTION_TIME:
                    self.session_reconnection_time = arg
                elif opt == "--" + PARAM_TEST_MODE:
                    self.test_mode = arg
                elif opt == "--" + PARAM_USE_PROXY:
                    self.use_proxy = arg
                else:
                    usage("Unknown option: " + opt, USAGE_ALL)
        except Exception as e:
            usage ("Unable to parse command line options\n\n   " + str(e), USAGE_ALL)

    def _read_command(self, command):
        self._get_usage(command)
        self.command = command

    def _get_usage(self, command):
        try:
            return {
                CMD_CREATE : USAGE_CREATE,
                CMD_DELETE : USAGE_DELETE,
                CMD_LIST : USAGE_LIST,
                CMD_SHOW : USAGE_SHOW,
                CMD_UPDATE : USAGE_UPDATE,
                CMD_VERSION : USAGE_VERSION,
                }[command]
        except Exception as e:
            usage ("Unknown command: " + command , USAGE_ALL)

class AwsSession:
    config  = None
    aws_session = None
    aws_credentials = []

    def __init__ (self, config):
        self.config = config
        self._create_aws_session()

    def _create_aws_session (self):
       
        try:
            if self.config.aws_access_key_id is None or self.config.aws_secret_access_key is None:
                self._get_aws_configuration()
                self._select_aws_credentials()
            self.aws_session = boto3.session.Session(aws_access_key_id = self.config.aws_access_key_id,
                            aws_secret_access_key = self.config.aws_secret_access_key,
                            region_name = self.config.region)
        except Exception as e:
            log_error("Unable to create AWS session\n   " + str(e))

    def _select_aws_credentials (self):
        # Single profile
        if len(self.aws_credentials) == 1:
            self.config.aws_access_key_id = self.aws_credentials[0][AWS_ACCESS_KEY_ID]
            self.config.aws_secret_access_key = self.aws_credentials[0][AWS_SECRET_ACCESS_KEY]
            return
        # Multiple profile
        while True:
            menu = LINE + "Following AWS credential profiles have been found:\n"
            for i in range (0, len (self.aws_credentials)):
                menu += "   " + str(i+1) + " - " + self.aws_credentials[i][AWS_PROFILE] + "\n"
            menu += "Select credentials profile: "
            profile=0
            try:
                profile = int(raw_input(menu))
            except Exception as e:
                log_warn("Unable to get profile from input")
            if profile >= 1 and profile <= len(self.aws_credentials):
                self.config.aws_access_key_id = self.aws_credentials[profile - 1][AWS_ACCESS_KEY_ID]
                self.config.aws_secret_access_key = self.aws_credentials[profile - 1][AWS_SECRET_ACCESS_KEY]
                return
            print ("Invalid selection")

    def _get_aws_configuration (self):
        config_locations = [AWS_CREDENTIALS_FILE, AWS_CONFIG_FILE]
        for location in config_locations:
            if os.path.exists(location):
                aws_config = ConfigParser.RawConfigParser()
                aws_config.read(location)
                self._get_aws_credentials(aws_config)
        if len(self.aws_credentials) == 0:
            aws_config = self._gather_aws_credentials()
            self._get_aws_credentials(aws_config)

    def _get_aws_credentials (self,aws_config):
        sections =  aws_config.sections() + [ConfigParser.DEFAULTSECT]
        for profile in sections:
            access = None
            secret = None
            if aws_config.has_option(profile, AWS_ACCESS_KEY_ID):
                access = aws_config.get(profile, AWS_ACCESS_KEY_ID)
            if aws_config.has_option(profile, AWS_SECRET_ACCESS_KEY):
                secret = aws_config.get(profile, AWS_SECRET_ACCESS_KEY)
            if not access is None and not secret is None:
                log ("Found AWS profile: " + profile)
                self.aws_credentials.append({
                    AWS_PROFILE : profile,
                    AWS_ACCESS_KEY_ID : access,
                    AWS_SECRET_ACCESS_KEY : secret
                })

    def _gather_aws_credentials(self):
        print (LINE +
              "AWS credentials not configured. Access and secret keys must be \n"
              "provided in order to allow Kurento tools to access AWS APIs.\n"
              "\n"
              "Solution 1 : If you're the account administrator execute following procedure:\n"
              "  1 - Navigate to https://console.aws.amazon.com/iam/home?#security_credential\n"
              "  2 - Open section Access Keys (Access Key ID and Secret Access Key)\n"
              "  3 - Press button Create New Access Key\n"
              "\n"
              "Solution 2 : If you're not the account administrator you still can generate credentials\n"
              "with following procedure\n"
              "  1 - Navigate to https://myaccount.signin.aws.amazon.com/console. Your AWS\n"
              "      administrator will provide you the value for myaccount\n"
              "  2 - Login to AWS console with you IAM user and password. Ask your AWS\n"
              "      administrator if you don't have an IAM user\n"
              "  3 - Navigate to IAM home https://console.aws.amazon.com/iam/home#home\n"
              "  4 - Open section 'Rotate your access keys' and click 'Manage User Access Key'\n"
              "  5 - Go to section 'Security Credentials' and click 'Create Access Key'\n"
              + LINE)
        aws_config = ConfigParser.RawConfigParser()
        while True:
            aws_access_key_id = raw_input ("Enter AWS Access Key ID:")
            if not aws_access_key_id is "":
                aws_config.set(ConfigParser.DEFAULTSECT, AWS_ACCESS_KEY_ID, aws_access_key_id)
                break
        while True:
            aws_secret_access_key = raw_input ("Enter AWS Secret Access Key:")
            if not aws_secret_access_key is "":
                aws_config.set(ConfigParser.DEFAULTSECT, AWS_SECRET_ACCESS_KEY, aws_secret_access_key)
                break
        if not os.path.exists(AWS_CONFIG_DIR):
            os.makedirs(AWS_CONFIG_DIR)
        aws_config.write (open(AWS_CREDENTIALS_FILE, 'w'))
        return aws_config

    def client (self,service):
        return self.aws_session.client(service)

class KurentoCluster:
    "Kurento Cluster"

    config = None
    template = None
    params = []
    default_params = []
    session = None
    images = {}
    stack = {}
    auto_scaling_groups = {}

    def __init__ (self, session, config):
        # Record basic config
        self.config = config
        self.session = session

        # Create AWS clients
        try:
            self.aws_cf = self.session.client('cloudformation')
            self.aws_autosc = self.session.client('autoscaling')
            self.aws_ec2 = self.session.client('ec2')
            self.aws_route53 = self.session.client('route53')
            self.aws_s3 = self.session.client('s3')
        except Exception as e:
            log_error("Unable to create AWS client\n   " + str(e))

        # Validate configuration
        self._validate_mandatory_parameters()
        if self.config.command == CMD_CREATE or self.config.command == CMD_UPDATE:
            self._validate_mandatory_parameters_stack ()
            self._validate_mandatory_parameters_create ()
            self._validate_s3 ()
            self._validate_autoscaling ()
            self._validate_route53 ()
            self._validate_ssl ()
            self._validate_dns ()

        elif self.config.command == CMD_DELETE:
            self._validate_mandatory_parameters_stack()

    def _validate_mandatory_parameters (self):
        if self.config.region is None:
            usage (MISSING_REGION, USAGE_REGION)

    def _validate_mandatory_parameters_stack (self):
        if self.config.stack_name is None:
            usage (MISSING_STACK_NAME, USAGE_STACK_NAME)
        if not re.match("^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$", self.config.stack_name):
            usage (INVALID_ALPHANUMERIC_STACK_NAME, USAGE_STACK_NAME)
        if self.config.stack_name.endswith("-"):
            usage (INVALID_ENDWITH_HYPEN_STACK_NAME, USAGE_STACK_NAME)
        if len(self.config.stack_name) >= 128:
            usage (INVALID_LENGTH_STACK_NAME, USAGE_STACK_NAME)

    def _validate_mandatory_parameters_create (self):
        if os.path.exists(self.config.template_file):
            try:
                self.config.template_body = open(self.config.template_file).read()
            except Exception as e:
                log_error (OPEN_TEMPLATE + "\n\n   " + str(e))
        else:
            log_error (MISSING_TEMPLATE)
        if self.config.template_body is None:
            log_error ("Empty CloudFormation template body. Verify file exists: " + TEMPLATE_FILE )
        if not self.config.kurento_api_key is None and not self.config.kurento_api_key.isalnum():
            usage (ALPHANUMERIC_KURENTO_API_KEY, USAGE_KURENTO_API_KEY)

    def _validate_autoscaling (self):
        if self.config.min_capacity is None or self.config.max_capacity is None:
            if self.config.desired_capacity is None:
                self.config.desired_capacity = "1"
            self.config.min_capacity = self.config.desired_capacity
            self.config.max_capacity = self.config.desired_capacity
        elif self.config.min_capacity > self.config.max_capacity:
            log_error (MIN_LARGER_MAX)
        else:
            if self.config.desired_capacity is None:
                self.config.desired_capacity = self.config.min_capacity
        if not self.config.cost_map is None:
            if re.match("^\w+=\d+(,\w+=d\+)*", self.config.cost_map) is None:
                log_error("Param " + PARAM_COST_MAP + ". Bad format: " + self.config.cost_map)

    def _validate_s3 (self):
        if not self.config.aws_s3_bucket_name is None:
            try:
                self.aws_s3.head_bucket(
                    Bucket = self.config.aws_s3_bucket_name
                    )
                # Bucket exists and user has permissions
            except Exception as e:
                # Bucket does not exists or no permissions
                try:
                    self.aws_s3.create_bucket(
                        Bucket = self.config.aws_s3_bucket_name
                    )
                except Exception as e:
                    # No permissions
                    log_error("Unable to access bucket: "+ self.config.aws_s3_bucket_name + "\n\n   " + str(e))
        else:
            bucket_name = self.config.region + "-" + self.config.stack_name.lower()
            try:
                self.aws_s3.head_bucket(
                    Bucket = bucket_name
                )
                # Bucket already exists => initialize config to avoid CF to create again
                self.config.aws_s3_bucket_name = bucket_name
            except Exception as e:
                # Bucket does not exists or no permissions. CF will try to create and then provide report
                log("Cluster will try to create bucket: " + self.config.region + "-" + self.config.stack_name)

    def _validate_route53 (self):
        if not self.config.hosted_zone_id  is None:
            try:
                hosted_zone = self.aws_route53.get_hosted_zone ( Id = self.config.hosted_zone_id )
            except Exception as e:
                log_error("Unable to get AWS hosted zone info\n\n   " + str(e))
            self.config.hosted_zone_fqdn = hosted_zone['HostedZone']['Name'].rstrip('.')

    def _validate_ssl (self):
        # SSL verifications
        if  not self.config.ssl_cert is None and self.config.ssl_key is None:
            usage ("Private Key must be provided with SSL certificate", USAGE_SSL)
        if self.config.ssl_cert is None:
            # Nothing to validate
            return

        cert = None
        priv = None
        pub = None

        # Verify PEM file exists for CERT
        if os.path.exists(self.config.ssl_cert):
            cert_str = open(self.config.ssl_cert).read()
            self.config.ssl_cert_chunks = [cert_str[i:i+4096] for i in range(0, len(cert_str), 4096)]
            cert = crypto.load_certificate (crypto.FILETYPE_PEM, cert_str)
            pub = cert.get_pubkey()
        else:
            usage ("SSL certificate not found or unable to open: " + self.config.ssl_cert, USAGE_SSL)

        # Verify PEM file exists for KEY
        if os.path.exists(self.config.ssl_key):
            priv_str = open(self.config.ssl_key).read()
            self.config.ssl_key_chunk=priv_str
            priv = crypto.load_privatekey(crypto.FILETYPE_PEM, priv_str)
        else:
            usage ("SSL private key not found or unable to open: " + self.config.ssl_key, USAGE_SSL)

        # Record SSL cert Common Name
        for cmp, val in cert.get_subject().get_components():
            if cmp == 'CN':
                self.config.ssl_common_name = val
                self.config.ssl_fqdn = val.lstrip('*').lstrip('.')
                # Check if certificate is wildcard
                if val.startswith('*.'):
                    self.config.ssl_wildcard = True
                    log ("Found wildcard certificate with CN: " + self.config.ssl_common_name)
                else:
                    self.config.ssl_wildcard = False
                    log ("Found certificate with CN: " + self.config.ssl_common_name)
                break

        # Validate Certificate matches hosted zone, if provided
        if not self.config.hosted_zone_fqdn is None:
            if ((self.config.ssl_wildcard == False and self.config.hosted_zone_fqdn != re.sub('^.+?\.','',self.config.ssl_fqdn)) or
                (self.config.ssl_wildcard == True and self.config.hosted_zone_fqdn != self.config.ssl_fqdn)):
                usage("SSL certificate name does not match hosted zone FQDN\n"
                  "\n  SSL common name   : " + self.config.ssl_common_name +
                  "\n  Hosted zone domain: " + self.config.hosted_zone_fqdn, USAGE_ROUTE53)

    def _validate_dns (self):
        if self.config.ssl_wildcard == False:
            self.config.cluster_fqdn = self.config.ssl_fqdn
        elif not self.config.hosted_zone_fqdn is None:
            self.config.cluster_fqdn = self.config.stack_name + "." + self.config.hosted_zone_fqdn
        elif not self.config.ssl_fqdn is None:
             self.config.cluster_fqdn = self.config.stack_name + "." + self.config.ssl_fqdn

    def _set_params (self):
        # Set parameters
        self._add_param ("KeyName", self.config.aws_key_name)
        self._add_param ("KurentoLoadBalancerName",(self.config.stack_name + "KurentoLoadBalancer")[:31])
        self._add_param ("DesiredCapacity",self.config.desired_capacity)
        self._add_param ("MaxCapacity", self.config.max_capacity)
        self._add_param ("MinCapacity", self.config.min_capacity)
        self._add_param ("InspectorUser", self.config.inspector_user)
        self._add_param ("InspectorPass", self.config.inspector_pass)
        self._add_param ("InstanceTenancy",self.config.aws_instance_tenancy)
        self._add_param ("InstanceType",self.config.aws_instance_type)
        self._add_param ("AppInstanceType", self.config.aws_app_instance_type if not self.config.aws_app_instance_type is None else self.config.aws_instance_type)
        self._add_param ("ApiKey",self.config.kurento_api_key)
        self._add_param ("ApiOrigin",self.config.kurento_api_origin)
        self._add_param ("ControlOrigin",self.config.control_origin)
        self._add_param ("CostMap",self.config.cost_map)
        self._add_param ("EnableTurn",self.config.enable_turn)
        self._add_param ("TurnUsername",self.config.turn_username)
        self._add_param ("TurnPassword",self.config.turn_password)
        self._add_param ("HostedZoneId",self.config.hosted_zone_id)
        self._add_param ("DnsName", self.config.cluster_fqdn)
        self._add_param ("UserS3Bucket", self.config.aws_s3_bucket_name)
        self._add_param ("LogStorage", self.config.log_storage)
        self._add_param ("ElasticSearchTransport", self.config.elasticsearch_transport)
        self._add_param ("ElasticSearchUser", self.config.elasticsearch_user)
        self._add_param ("ElasticSearchPass", self.config.elasticsearch_pass)
        self._add_param ("ElasticSearchSsl", self.config.elasticsearch_ssl)
        self._add_param ("Version", self.config.version)
        # Certificate must be split in chunks of 4096 due to AWS limitation
        for i in range (len(self.config.ssl_cert_chunks)):
            self._add_param("SslCertificate" + str(i+1), self.config.ssl_cert_chunks[i] )
            self._add_param("SslKey", self.config.ssl_key_chunk)
        # Set test parameter
        self._add_param ("AppUrl", self.config.app_url)
        self._add_param("AutoscalingHeartbeatTimeout", self.config.autoscaling_heartbeat_timeout)
        self._add_param ("HealthCheckGracePeriod",self.config.health_check_grace_period)
        self._add_param ("KmsControllerUrl", self.config.kms_controller_url)
        self._add_param ("SessionReconnectionTime" , self.config.session_reconnection_time)
        self._add_param ("TestMode", self.config.test_mode)
        self._add_param ("UseProxy", self.config.use_proxy)
        # Create KMS certificate
        key = crypto.PKey()
        key.generate_key(crypto.TYPE_RSA, 2048)
        cert = crypto.X509()
        cert.get_subject().CN = "*.kurento.org"
        cert.set_serial_number(1000)
        cert.gmtime_adj_notBefore(0)
        cert.gmtime_adj_notAfter(100*365*24*60*60)
        cert.set_issuer(cert.get_subject())
        cert.set_pubkey(key)
        cert.sign(key, 'sha1')
        pem = crypto.dump_certificate(crypto.FILETYPE_PEM, cert) + crypto.dump_privatekey(crypto.FILETYPE_PEM, key)
        self._add_param ("KmsCertificate",pem)

    def _set_image_mapping_name (self):
        # Configure Cluster image name
        if 'cluster' in self.images:
            self._add_param('KmsImageMapName', 'cluster')
        else:
            log_error ("elasticRTC not supported in region: " + self.config.region)
        # Verify if any APP is being enabled
        app = self.config.enable_app
        if not app is None:
            if app != 'cluster' and app in self.images:
                self._add_param('AppImageMapName', app)
                self._add_param('EnableApp','true')
                self._add_param('AppName', app)
            else:
                log_error ("elasticRTC App: " + app +" not supported in region: " + self.config.region)

    def _build_cloudformation_template (self):
        # Get AWS images
        log ("Build CloudFormation template")
        #print self.config.template_body
        try:
            self.template = json.loads(self.config.template_body)
        except Exception as e:
            raise
            log_error ("Malformed CloudFormation template\n\n   " + str(e) )

        try:
            mappings = {}
            mappings['RegionMap']={}
            mappings['RegionMap'][self.config.region]={}
            for app in self.images:
                # Search AMI
                if not self.config.version is None:
                    if self.config.version in self.images[app]['Versions'].keys():
                        image_id = self.images[app]['Versions'][self.config.version]['latest_image_id']
                    else:
                        log_error ("App: " + app + " is not supported in region: " + self.config.region + " for version: " + self.config.version)
                else:
                    image_id = self.images[app]['latest_image_id']

                # Add AMI to mappings
                if not image_id is None:
                    mappings['RegionMap'][self.config.region][app]= image_id
                else:
                    log_error ("elasticRTC not supported in region: " + self.config.region)
            self.template['Mappings'] = mappings
            self.config.version = self.images['cluster']['latest_version']
        except Exception as e:
            raise
            log_error("Failure searching KMS AMI in region:" + self.config.region + "\n\n   " + str(e))

        # Calculate scaling policies
        step_in_policy = self._parse_step_policy(self.config.scale_in_policy)
        step_out_policy = self._parse_step_policy(self.config.scale_out_policy)

        # Write alarm thresholds to template
        l_th = int(step_in_policy[-1][0])
        h_th = int(step_out_policy[0][0])
        self.template['Resources']['KurentoUsageAlarmLow']['Properties']['Threshold'] = l_th
        self.template['Resources']['KurentoUsageAlarmHigh']['Properties']['Threshold'] = h_th

        # Write scale in step policy to template
        lower_bound = None
        for (b,c) in step_in_policy:
            step = {}
            if lower_bound:
                step['MetricIntervalLowerBound'] = lower_bound
            upper_bound = int(b) - l_th
            step['MetricIntervalUpperBound'] = upper_bound
            step['ScalingAdjustment'] = -int(c)
            self.template['Resources']['KurentoScaleDownPolicy']['Properties']['StepAdjustments'].append(step)
            lower_bound = upper_bound

        upper_bound = None
        for (b,c) in reversed(step_out_policy):
            step = {}
            if upper_bound:
                step['MetricIntervalUpperBound'] = upper_bound
            lower_bound = int(b) - h_th
            step['MetricIntervalLowerBound'] = lower_bound
            step['ScalingAdjustment'] = c
            self.template['Resources']['KurentoScaleUpPolicy']['Properties']['StepAdjustments'].append(step)
            upper_bound = lower_bound

    def _describe_images (self):
        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            sys.stdout = blank
            aws_ec2 = self.session.client('ec2')
            cluster_images = aws_ec2.describe_images(
                Filters = [
                    {
                        'Name' : 'description',
                        'Values' : [ KMS_AMI_DESCRIPTION ,
                                     ROOM_AMI_DESCRIPTION
                        ]
                    }
                ]
            )
            #print json.dumps(cluster_images)
            sys.stdout=stdout
            self.images = {}
            for image in cluster_images['Images']:
                # Verify image owner
                #print "FOUND Image from owner: " + str(image['OwnerId'])
                if image['OwnerId'] != "135888621974":
                    continue
                # Get image version
                print('Image name: ',image['Name'])
                version = re.search("KMS-(?P<version>\d+\.\d+\.\d+\S*)\.trusty",image['Name']).group('version')
                creation_ts = int(datetime.datetime.strptime(re.sub('\..*?$','',image['CreationDate']),"%Y-%m-%dT%H:%M:%S").strftime("%s"))
                #print "FOUND: " + str(version) + " at: " + str(creation_ts) + " from: " + image['OwnerId']
                app = re.match ("^(?P<app>(CLUSTER|ROOM))",image['Name']).group('app').lower()
                if not version is None:
                    if not app in self.images:
                        self.images[app] = {}
                        self.images[app]['latest_ts'] = 0
                        self.images[app]['Versions'] = {}
                    if not version in self.images[app]['Versions'].keys():
                        self.images[app]['Versions'][version]={}
                        self.images[app]['Versions'][version]['latest_ts'] = 0
                    if self.images[app]['Versions'][version]['latest_ts'] < creation_ts:
                        self.images[app]['Versions'][version]['latest_image_id'] = image['ImageId']
                        self.images[app]['Versions'][version]['latest_ts'] = creation_ts
                        #print "SET " + app + " Version: " + version + " LATEST = " + self.images[app]['Versions'][version]['latest_image_id']
                if self.images[app]['latest_ts'] < creation_ts:
                    self.images[app]['latest_image_id'] = image['ImageId']
                    self.images[app]['latest_ts'] = creation_ts
                    self.images[app]['latest_version'] = version
                    #print "SET " + app + " LATEST = " + self.images[app]['latest_image_id']

        except Exception as e:
            sys.stdout=stdout
            raise
            log_error("Failure searching ElasicRTC AMI in region: " + self.config.region + "\n\n   " + str(e))

        blank.close()

    def _get_image_app (self, image_id):
        for app in self.images:
            if self.images[app]['latest_image_id'] == image_id:
                return app
            if 'Versions' in self.images:
                for version in self.images['Versions']:
                    if version['latest_image_id'] == image_id:
                            return app
        return 'cluster'

    def _describe_stack (self):
        self.stack = {}
        try:
            # Get stack output data
            stack_list = self.aws_cf.describe_stacks ( StackName = self.config.stack_name )
            for s in stack_list['Stacks']:
                if s['StackName'] == self.config.stack_name:
                    # Collect status
                    self.stack['status'] = s['StackStatus']
                    # Collect params
                    self.stack['parameters'] = {}
                    if 'Parameters' in s:
                        for p in s['Parameters']:
                            self.stack['parameters'][p['ParameterKey']] = p['ParameterValue']
                    # Collect outputs
                    if 'Outputs' in s:
                        for output in s['Outputs']:
                            if output['OutputKey'] == 'URL':
                                self.stack['url'] = output['OutputValue']
                            elif output['OutputKey'] == 'AppURL':
                                self.stack['app_url'] = output['OutputValue']
                            elif output['OutputKey'] == 'AWSCname':
                                self.stack['aws-cname'] = output ['OutputValue']
                            elif output['OutputKey'] == 'ClusterCname':
                                self.stack['cluster-cname'] = output ['OutputValue']
                    break
            # Get resource details
            self.stack['dns_auto'] = False
            stack_resources = self.aws_cf.describe_stack_resources ( StackName = self.config.stack_name )
            for resource in stack_resources['StackResources']:
                if resource['LogicalResourceId'] == 'KurentoResourceSet':
                    self.stack['dns_auto'] = True
                    break
        except Exception as e:
            log_error("Unable to retrieve info from cluster stack:\n\n   " + str(e))

    def _describe_auto_scaling_groups (self):
        self.auto_scaling_groups = {}
        try:
            # Get autoscaling group name
            stack_resources = self.aws_cf.describe_stack_resources( StackName = self.config.stack_name )
            group_names = []
            for resource in stack_resources['StackResources']:
                if resource['ResourceType'] == 'AWS::AutoScaling::AutoScalingGroup':
                    group_names.append(resource['PhysicalResourceId'])

            groups = self.aws_autosc.describe_auto_scaling_groups ( AutoScalingGroupNames = group_names )
            for group in groups['AutoScalingGroups']:
                for instance in group['Instances']:
                    instance = self._describe_instance(instance['InstanceId'])
                    if not instance is None:
                        app = self._get_image_app (instance['image_id'])
                        if not app in self.auto_scaling_groups:
                            self.auto_scaling_groups[app] = {}
                            self.auto_scaling_groups[app]['instances'] = []
                        self.auto_scaling_groups[app]['instances'].append ( instance )
        except Exception as e:
            raise
            log_error("Unable to retrieve autoscaling group info:\n\n   " + str(e))

    def _describe_instance (self, instance_id):
        try:
            instance_info = self.aws_ec2.describe_instances( InstanceIds = [ instance_id ])
            if instance_info['Reservations'][0]['Instances'][0]['State']['Name'] == 'running':
                instance = {}
                instance['id'] = instance_id
                instance['public_ip'] = instance_info['Reservations'][0]['Instances'][0]['NetworkInterfaces'][0]['Association']['PublicIp']
                instance['private_ip'] = instance_info['Reservations'][0]['Instances'][0]['NetworkInterfaces'][0]['PrivateIpAddress']
                instance['type'] = instance_info['Reservations'][0]['Instances'][0]['InstanceType']
                instance['image_id'] = instance_info['Reservations'][0]['Instances'][0]['ImageId']
                return instance
            else:
                return None
        except Exception as e:
            raise
            log_error("Unable to retrieve instance info:\n\n   " + str(e))

    def _parse_step_policy (self, step_policy_str):
        step_policy = {}
        if not re.match("^\d+=\d+(,\d+=\d+)*$", step_policy_str):
            log_error (SCALE_POLICY_BAD_FORMAT + " : " + step_policy_str)
        for step in re.finditer ("(?P<bound>\d+)=(?P<change>\d+)", step_policy_str):
            step_policy[step.group('bound')]=step.group('change')
        return sorted(step_policy.items())

    def _add_param (self, parameter_key, parameter_value):
        if parameter_value is None:
            # If not specified in CLI then get current value from stack
            if parameter_key in self.default_params:
                parameter_value = self.default_params[parameter_key]
        if not parameter_value is None and parameter_value != 'default':
            self.params.append ({
                "ParameterKey" : parameter_key,
                "ParameterValue" : parameter_value
            })

    def _wait_cf_cmd (self, wait_state, end_state, message):
        if not out_json:
            sys.stdout.write(message)
            sys.stdout.flush()
        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        while True:
            try:
                # boto3 is printing data to STDOUT
                sys.stdout = blank
                request = self.aws_cf.describe_stacks ( StackName = self.config.stack_name )
                event_report = self.aws_cf.describe_stack_events ( StackName = self.config.stack_name )
                sys.stdout=stdout
            except Exception as e:
                sys.stdout=stdout
                if 'exist' in str(e):
                    # This is very specific for command delete
                    request['Stacks'][0]['StackStatus'] = end_state
                else:
                    log_error("Unable to retrieve info for stack: " + self.config.stack_name)

            if len (request['Stacks']) == 1:
                status = request['Stacks'][0]
                if status['StackStatus'] in wait_state:
                    if not out_json:
                        sys.stdout.write('.')
                        sys.stdout.flush()
                elif status['StackStatus'] in end_state:
                    if not out_json:
                        sys.stdout.write('[OK]\n')
                        sys.stdout.flush()
                    break
                else:
                    fail_reason = ""
                    for event in event_report['StackEvents']:
                        if 'FAILED' in event['ResourceStatus']:
                            fail_reason += event['ResourceStatusReason'] + '\n'
                    log_error ("Unsupported AWS status: " + status['StackStatus'] + "\n\n" + fail_reason)
            elif len (request['Stacks']) == 0:
                log_error("AWS reports unknown stack: " + self.config.stack_name )
            else:
                log_error("AWS reports to many stacks:\n\n " + resquest)
            time.sleep(5)
        blank.close()

    def _create (self):
        # Build CloudFormation stack
        log ("Start CloudFormation stack: " + self.config.stack_name )
        self._describe_images ()
        self._build_cloudformation_template ()
        self._set_image_mapping_name ()
        self._set_params ()

        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            sys.stdout = blank
            self.aws_cf.create_stack(
                StackName = self.config.stack_name,
                TemplateBody = json.dumps(self.template),
                Capabilities = [
                    'CAPABILITY_IAM',
                ],
                Parameters = self.params
            )
            sys.stdout = stdout
        except Exception as e:
            sys.stdout = stdout
            log_error("CloudFormation did not complete creation of stack: " + self.config.stack_name +
                " due to:\n\n   " + str(e))
        self._wait_cf_cmd('CREATE_IN_PROGRESS', 'CREATE_COMPLETE', 'Creating cluster')
        # Wait for DNS name to be available
        if not self.config.hosted_zone_fqdn is None:
            resolver = dns.resolver.Resolver()
            while True:
                dns_info = []
                try:
                    dns_info = resolver.query(self.config.cluster_fqdn, 'CNAME')
                except Exception as e:
                    log("Resolver error waiting DNS record: " + str(e))
                if len (dns_info) > 0 :
                    break
                time.sleep (5)

        # Print stack details
        self._show()

    def _delete (self):
        log ("Deleting CloudFormation stack: " + self.config.stack_name )
        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            # Do not delete any stack not being Kurento Cluster
            sys.stdout = blank
            request = self.aws_cf.get_template(StackName = self.config.stack_name)
            if not 'KurentoCluster' in request['TemplateBody']['Parameters']:
                log_error("Not an elasticRTC Cluster: " + self.config.stack_name)
            self.aws_cf.delete_stack(StackName = self.config.stack_name)
            sys.stdout = stdout
        except Exception as e:
            sys.stdout = stdout
            log_error("CloudFormation did not complete deletion of stack: " + self.config.stack_name +
                " due to:\n\n   " + str(e))

        self._wait_cf_cmd('DELETE_IN_PROGRESS', 'DELETE_COMPLETE', 'Deleting cluster')

    def _update (self):
        log ("Updating CloudFormation stack: " + self.config.stack_name )
        # Get current stack
        stack = self._describe_stack ()
        self.default_params = stack['parameters']
        # Build updated template and set params
        self._build_cloudformation_template ()
        self._set_image_mapping_name ()
        self._set_params ()

        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            sys.stdout = blank
            self.aws_cf.update_stack(
                StackName = self.config.stack_name,
                TemplateBody = json.dumps(self.template),
                Capabilities = [
                    'CAPABILITY_IAM',
                ],
                Parameters = self.params
            )
            sys.stdout = stdout
        except Exception as e:
            sys.stdout = stdout
            raise
            log_error("CloudFormation did not complete update of stack: " + self.config.stack_name +
                " due to:\n\n   " + str(e))
        self._wait_cf_cmd('UPDATE_IN_PROGRESS', 'UPDATE_COMPLETE', 'Updating cluster')

    def _list (self):
        res_str = LINE + "List elasticRTC stacks:" +CR
        res_obj = []
        try:
            for stack in self.aws_cf.list_stacks()['StackSummaries']:
                if self.config.region in stack['StackId'] and stack['StackStatus'] != 'DELETE_COMPLETE':
                    request = self.aws_cf.get_template(StackName = stack['StackName'])
                    if 'KurentoCluster' in request['TemplateBody']['Parameters']:
                        res_str += I + "Name: " + stack['StackName'] + ", Status: " + stack['StackStatus'] +CR
                        res_stack = {}
                        res_stack['name'] = stack['StackName']
                        res_stack['status'] = stack['StackStatus']
                        res_obj.append (res_stack)
            res_str += LINE
        except Exception as e:
            log_error("Unable to retrieve list of clusters due to:\n\n   " + str(e))
        if out_json == True:
            res_str = json.dumps (res_obj)
        print (res_str)

    def _show (self):
        res_str = ""
        res_obj = {}
        cluster = {}
        dns_notice = ""
        try:
            # Get cluster info
            self._describe_images ()
            self._describe_stack()
            self._describe_auto_scaling_groups ()

            # print cluster INFO
            res_str += LINE
            res_str += "elasticRTC Cluster:" + self.config.stack_name + CR
            # Show Status
            res_str += CR+I + "Status:" + CR
            res_str += I2 + self.stack['status'] + CR
            res_obj['Status'] = self.stack['status']
            # Show version
            ami = self.auto_scaling_groups['cluster']['instances'][0]['image_id']
            version = 'unknown'
            for v in self.images['cluster']['Versions']:
                if self.images['cluster']['Versions'][v]['latest_image_id'] == ami:
                    version = v
            res_str += CR+I + "Version: " + CR
            res_str += I2 + version + CR
            res_obj['Version'] = version
            # Show Cluster URL
            if 'url' in self.stack:
                res_str += CR+I + "Cluster URL:" + CR
                res_str += I2 + self.stack['url'] + CR
                res_obj['ClusterUrl'] = self.stack['url']
            if not self.stack['dns_auto'] and 'cluster-cname' in self.stack and not self.stack['cluster-cname'] == '':
                dns_notice += I2 + "Note: Following CNAME record must be manually created: " + CR
                dns_notice += I2 + "    " + self.stack['cluster-cname'] + "  CNAME  " + self.stack['aws-cname'] + CR
                res_str += dns_notice
            # Show cluster instances
            res_obj['ClusterInstances'] = []
            res_str += CR+I + "Cluster Instances: " +  str(len (self.auto_scaling_groups['cluster']['instances'])) + CR
            for instance in self.auto_scaling_groups['cluster']['instances']:
                res_str += I2 + instance['id'] + ": " + instance['type'] + " - " + instance['private_ip']+ "/" + instance['public_ip'] + CR
                res_instance = {}
                res_instance['id'] = instance['id']
                res_instance['private_ip'] = instance['private_ip']
                res_instance['public_ip'] = instance['public_ip']
                res_instance['type'] = instance['type']
                res_obj['ClusterInstances'].append(res_instance)
            # Show app name
            res_str += CR+I + "APP: " + CR
            if 'app_url' in self.stack:
                res_str += I2 + self.stack['parameters']['AppName'] + CR
                res_obj['Application'] = self.config.enable_app
            else:
                res_str += I2 + "none" + CR
                res_obj['Application'] = 'none'
            # Show App URL
            if 'app_url' in self.stack:
                res_str += CR+I + "App URL:" + CR
                res_str += I2 + self.stack['app_url'] + CR
                res_str += dns_notice
                res_obj['AppUrl'] = self.stack['app_url']
            # Show App instances
            if 'AppName' in self.stack['parameters'] and self.stack['parameters']['AppName'] in self.auto_scaling_groups:
                app = self.stack['parameters']['AppName']
                res_obj['AppInstances'] = []
                res_str += CR+I + "App Instances: " +  str(len (self.auto_scaling_groups[app]['instances'])) + CR
                for instance in self.auto_scaling_groups[app]['instances']:
                    res_str += I2 + instance['id'] + ": " + instance['type'] + " - " + instance['private_ip']+ "/" + instance['public_ip'] + CR
                    res_instance = {}
                    res_instance['id'] = instance['id']
                    res_instance['private_ip'] = instance['private_ip']
                    res_instance['public_ip'] = instance['public_ip']
                    res_instance['type'] = instance['type']
                    res_obj['AppInstances'].append(res_instance)
            # Show build parameters
            res_obj['Parameters'] = {}
            res_str += CR+I + "Build parameters:" + CR
            col_width = max(len(self.config.aws_param_mappings[key]) for key in self.config.aws_param_mappings) + 1
            for aws_param in sorted(self.config.aws_param_mappings, key=self.config.aws_param_mappings.get):
                param_lines = self.stack['parameters'][aws_param].splitlines()
                if len(param_lines) > 0:
                    param_value = param_lines[0]
                else:
                    param_value = ""
                res_str += I2 + self.config.aws_param_mappings[aws_param].ljust(col_width) + ": " + param_value + CR
                for line in param_lines[1:]:
                    res_str += I2 + "".ljust(col_width +2 ) + line + CR
                res_obj['Parameters'][aws_param] = self.stack['parameters'][aws_param]
            res_str += LINE
        except Exception as e:
            raise
            log_error("Unable to retrieve cluster info:\n\n   " + str(e))
        if out_json == True:
            res_str = json.dumps(res_obj)
        print res_str

    def _version (self):
        res_str = ""
        res_obj = {}
        self._describe_images ()
        res_str += LINE
        res_str += "elasticRTC versions: " + CR
        res_obj= {}
        res_obj['Versions'] = []
        for version in sorted(self.images['cluster']['Versions']):
            res_str += I2 + version + CR
            res_obj['Versions'].append(version)
        res_str += LINE
        if out_json == True:
            res_str = json.dumps(res_obj)
        print res_str
        
    def execute (self):
        if self.config.command == CMD_CREATE:
            self._create()
        elif self.config.command == CMD_DELETE:
            self._delete()
        elif self.config.command == CMD_LIST:
            self._list()
        elif self.config.command == CMD_SHOW:
            self._show()
        elif self.config.command == CMD_UPDATE:
            self._update()
        elif self.config.command == CMD_VERSION:
            self._version()
        else:
            usage ("Unknown command: " + self.config.command, USAGE_ALL)

##### MAIN #####

# Parse command line arguments
config = KurentoClusterConfig(sys.argv[1:])
session = AwsSession(config)

# Execute cluster command
cluster = KurentoCluster(session, config)
cluster.execute()

# TODO: Autoscaling
# TODO: Runtime cluster reconfiguration
